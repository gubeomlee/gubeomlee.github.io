---
layout: default
title: Start
parent: Algorithm Basic
nav_order: 13
---

# Start

---

## 복잡도 분석

- 공간 복잡도: 연산량 대비 얼마나 적은 메모리 공간을 사용하는가
- 시간 복잡도: 연산량 대비 얼마나 적은 시간을 사용하는가
- 복잡도가 높을수록 효율성은 저하된다.

#### 시간복잡도 분석

- 하드웨어 환경에 따라 처리시간이 달라진다. 부동소수 처리 프로세스 존재, 나눗셈 가속기능, 입출력 장비의 성능이 영향을 미친다.
- 소프트웨어 환경에 따라 처리시간이 달라진다. 프로그램 언어의 종류, 운영체제, 컴파일러 종류가 영향을 미친다.

#### 복잡도의 점근적 표기

- 복잡도는 입력 크기에 대한 함수로 표기한다.
- 단순한 표기를 위해 점근적 표기를 사용한다.

#### O(Big-Oh) 표기

- 점근적 상한을 나타낸다.
- g(n)이 n<sub>0</sub>보다 큰 n에 대해서 항상 f(n) = O(g(n))보다 보다 크다.
- O(1): 상수 시간
- O(log n): 로그(대수) 시간
- O(n): 선형 시간
- O(n log n): 로그 선형 시간
- O(n^2): 제곱 시간
- O(n^3): 세제곱 시간
- O(2^n): 제수 시간

## 진수

#### 타진수 변환

- 원하는 타진법 수로 나눈 뒤 나머지를 거꾸로 읽는다.
- 149(10) = 10010101(2)
- 01|010|101(2) = 225(8)
- 1001|0101(2) = 95(16)

#### 컴퓨터에서 음의 정수 표현

- 최상위 비트가 양수면 0이고, 음수면 1이다.
- 1의 보수: 부호와 절대값으로 표현된 값을 부호비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환한다.
- -6 : 1000 0000 0000 0110 : 부호와 절대값 표현
- -6 : 1111 1111 1111 1001 : 1의 보수 표현
- 2의 보수: 1의 보수방법으로 표현된 값의 최하쉬 비트에 1을 더한다.
- -6 : 1111 1111 1111 1010 : 2의 보수 표현

## 실수

#### 실수 표현

- 실수 표현을 위해 고정 소수점, 부동 소수점 표기법을 사용한다.
- 고정 소수점은 부호 1비트, 정수 15비트, 소수 16비트를 사용한다.
- 부동 소수점은 소수점의 위치를 고정시켜 표현한다. 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현한다. 1001.0011 -> 1.0010011 \* 2^3
- 컴퓨터는 실수를 근사적으로 표현한다. 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장된다. 이때 생기는 오차가 계산 과정 다른 결과를 가져온다.
- 32비트 실수형은 6자리, 64비트 실수형은 15자리가 유효 자리다.

#### 실수 저장

- 단정도 실수는 부호 1비트, 지수 8비트, 가수 23비트 총 32비트를 사용한다.
- 배정도 실수는 부호 1비트, 지수 11비트, 가수 52비트 총 64비트를 사용한다.
- 지수부(exponent): 실제 소수점의 위치를 지수 승으로 표현한 것.
- 가수부(mantissa): 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것.

#### 단정도 실수 예시

- 정수부의 첫번째 자리가 1이 되도록 오른쪽으로 시프트한다.
- 소수점 이하를 23비트로 만든다.
- 소수점 이하만 가수 부분에 저장한다.
- 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소한다.
- 1001.0011
- 0001.0010 0110 0000 0000 0000 000
- 0010 0110 0000 0000 0000 000
- 1.0010 011 \* 2^3;
- 지수부에는 8비트가 배정된다. 음수값을 나타내기 위해 익세스 표현법(excess: 지수 값을 반으로 나눠 음수지수, 양수지수 표현하는 방법)으로 표현한다.
- 9.187500 = 0 | 1000 0010 | 0010 0110 0000 0000 0000 000
