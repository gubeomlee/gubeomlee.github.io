---
layout: default
title: 인덱스 기본
parent: SQLD
nav_order: 29
---

# 인덱스 기본

---

## 인덱스 개념

- 인덱스는 데이터베이스에서 검색속도를 향상시키기 위해 사용하는 기능이다.
- 인덱스는 인덱스 키로 정렬되어 있기 때문에 원하는 데이터를 빠르게 조회 가능하다.
- 관계형 데이터베이스에서 가장 많이 사용하는 인덱스는 B-트리다.
- 하나의 테이블에 여러개의 인덱스를 생성할 수 있고, 하나의 인덱스는 여러개의 컬럼으로 구성될 수 있다.
- 인덱스를 구성하는 컬럼의 정렬 순수에 따라 오름차순(ASC), 내림차순(DESC)으로 정렬된다.
- Unique Index에는 NULL값이 포함될 수 있다.

## 인덱스 장단점

- 장점: 검색속도가 빨라진다. 시스템 부하를 줄여서 성능을 향상시킨다.
- 단점: 추가적인 메모리 공간이 필요하다. 테이블에 데이터가 많을 경우 인덱스 생성기간이 오래걸린다. INSERT/UPDATE/DELETE 같은 변경 작업이 자주 발생시 오히려 성능이 저하된다.

## 인덱스 문법

#### 인덱스 생성

- CREATE 문을 사용하여 생성한다.
- 1개 이상의 컬럼을 사용해서 생성할 수 있다.
- 인덱스 생성시 동일 컬럼으로 구성된 인덱스를 중복해서 생성하는 것은 불가능하다. 다만 인덱스 구성 컬럼의 순서가 다르면 서로 다른 인덱스에 해당한다.
- 인덱스 키는 기본적으로 오름차순으로 정렬하고, "DESC"를 활용하여 내림차순으로 정렬한다.

```sql
CREATE INDEX IND_EMP ON EMP(ENAME, SAL DESC);
```

#### 인덱스 삭제

- DROP 문을 사용하여 삭제 가능하다.

```sql
DROP INDEX IND_EMP;
```

## 인덱스 스캔방식

#### Full Table Scan

- 테이블에 존재하는 모든 데이터를 읽어 가면서 조건에 맞으면 결과로 출력하고 아니면 버리는 방식으로 스캔한다.
- 이전에 데이터가 있었던 블록의 정보를 읽으며, 이들은 메모리에서 곧 제거될 수 있도록 관린한다.
- SQL문에 조건이 없거나, 사용 가능한 인덱스가 없는 경우 사용된다.

#### Index Unique Scan

- 인덱스의 키 값이 중복되지 않는 경우, 해당 인덱스를 사용할 때 발생한다.
- EMPNO가 중복되지 않는 경우 특정 하나의 EMPNO를 스캔한다.
- 등가조건만 사용한다.

#### Index Range Scan

- SELECT 문에서 특정 범위를 조회하는 WHERE 문을 사용할 경우에 발생한다.
- 데이터 양이 적은 경우 인덱스를 실행하지 않고 Full Table Scan이 될 수 있다.

#### Index Range Scan Descending

- 인덱스를 역순으로 스캔하여 Max 값을 쉽게 찾기 위해 사용한다.

#### Index Full Scan

- 인덱스에서 검색되는 인덱스 키가 많은 경우 Leaf Block 처음부터 끝까지 전체를 읽어 들인다.
- 데이터의 양이 많은 경우, 인덱스 스캔이 유리하지만, 데이터 대부분을 읽어야 할 때에는 Full Table Scan이 유리할 수도 있다.

## 인덱스 유형

#### B-트리 인덱스

- 루트블록, 브랜치블록, 리프블록으로 구성되어 있다.
- 리프블록은 인덱스 키와 ROWID로 구성되어 인덱스 키는 정렬되어 저장되어 있다.
- 루트블록부터 리프블록까지 거리가 일정한 트리구조를 가진 인덱스다.
- 트리 기반 인덱스는 일치 검색과 범위 검색 모두에 적합하다.
- 리프블록에는 보통 컬럼의 데이터와 해당 데이터를 가지고 있는 행의 위치를 가지는 레코드 식별자로 구성되어 있다.

#### 비트맵 인덱스

- 비트를 이용해서 컬럼 값을 저장하고 비트맵으로 저장된다.
- Distinct Value 개수가 적은 컬럼일 때 저장효율이 좋다.
- 여러 인덱스를 동시에 활용할 수 있다.
- Lock에 의한 DML 부하가 심해서 OLTP성 환경에 비트맵 인덱스를 쓸 수 있다.
- 읽기 위주의 대용량 데이터 웨어하우스 환경에 적합하다.
