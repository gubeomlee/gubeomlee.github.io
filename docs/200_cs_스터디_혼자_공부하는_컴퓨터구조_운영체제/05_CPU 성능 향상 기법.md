---
layout: default
title: CPU 성능 향상 기법
parent: CS 스터디 컴퓨터 구조, 운영체제
nav_order: 5
---

# 데이터

---

## 빠른 CPU를 위한 설계 기법

#### 클럭

- 클럭 속도가 빨라지면 CPU를 비롯한 부품들이 더 빠른 박자에 맞춰 작동할 것이다.
- 클럭은 항상 같은 속도를 유지하는 것이 아니라 고성능이 필요하면 순간적으로 속도를 높인다.
- 최대 클럭 속도를 강제로 더 끌어올릴 수 있는데, 이를 어버클럭킹이라고 한다.
- 클럭 속도를 높이면 발열이 증가한다. 클럭 속도를 높이는 것으로는 CPU 성능 향상에 한계가 있다.

#### 코어와 멀티코어

- 기술발전으로 CPU는 '명령어를 실행하는 부품'에서 '명령어를 실행하는 부품을 여러개 포함하는 부품'으로 범위가 확장되었다.
- 코어를 여러개 포함한 CPU를 멀티코어 CPU 또는 멀티코어 프로세스라고 부른다.
- 코어마다 연산이 적절히 분배되지 않으면 코어 수에 비례해서 연산속도가 증가하지 않는다.
- 작업량에 비해 지나치게 많은 코어는 성능개선에 기여하지 못한다.

#### 스레드

- CPU에 사용되는 하드웨어적 스레드와 프로그램에 사용되는 소프트웨어적 스레드가 있다.
- 하드웨어적 스레드: 하나의 코어가 동시에 처리할 수 있는 명령어 단위다. 하나의 코어가 여러 명령어를 동시에 처리하는 경우 멀티스레드 프로세서, 멀티스레드 CPU라고 한다. 프로그램 입장에서는 하드웨어 스레드는 '한번에 하나의 명령어를 처리하는 스레드'와 같다. 2코어 4스레드는 CPU가 4개 있는 것처럼 보이기 때문에 하드웨어적 스레드를 논리 프로세서라고 부르기도 한다.
- 멀티스레드 프로세서: 하나의 명령어를 처리하기 위한 레지스터를 여러개 가지고 있으면 된다.
- 소프트웨어적 스레드: 하나의 프로그램에서 독립적으로 실행되는 단위다. 1코어 1스레드 CPU도 소프트웨어적 스레드를 여러개 실행할 수 있다.

## 명령어 병렬 처리 기법

#### 명령어 파이프라인

- 명령어 처리과정은 같은 단계가 겹치지만 않으면 각 단계를 동시에 실행할 수 있다.
- 명령어 인출
- 명령어 해석
- 명령어 실행
- 결과 저장
- 명령어 파이프라이닝을 통해 성능 향상에 실패한 경우 이러한 상황을 파이프라인 위험이라고 한다. 파이프라인 위험으로 데이터 위험, 제어 위험, 구조적 위험이 있다.
- 데이터 위험: 명령어 간 '데이터 의존성'에 의해 발생한다. 어떤 명령어는 이전 명령어가 끝까지 실행한 뒤에 실행가능하다.
- 제어 위험: 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생한다. 프로그램 카운터가 갑자기 변하면 명령어 파이프라인에 미리 가지고 와서 처리 중이던 명령어들이 쓸모가 없어진다. 분기 예측은 프로그램이 어디로 분기할 지 미리 예측한 후 그 주소로 인출하는 기술이다.
- 구조적 위험: 명령어를 겹쳐 실행하는 과정 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때에 발생한다. 자원 위험이라고 부르기도 한다.

#### 슈퍼스칼라

- 오늘날 CPU는 여러 개의 파이프라인을 이용한다. 여러 개의 명려어 파이프라인을 포함한 구조를 '슈퍼스칼라'라고 한다.
- 슈퍼스칼라 구조로 명려어 처리가 가능한 CPU를 슈퍼스칼라 프로세서, 슈퍼스칼라 CPU라고 한다.
- 이론 적으로는 파이프라인의 개수에 비례해서 프로그램 처리 속도가 빨라진다. 단 예상치 못한 문제가 있으므로 반드시 비례하는 것은 아니다. 파이프라인 위험을 방지하기 위해 고도로 설계된다.

#### 비순차적 명령어 처리

- OoOE(Out-of-Order-Execution)라고 한다.
- 명령어들이 순차적으로 실행되지 않는다. 명령어의 '합법적 새치기'라고 볼 수 있다.
- 모든 명령어가 순차적으로만 실행되어야 한다면 예상치 못한 상황에서 명령어 파이프라인이 멈춰버린다.

## CISC와 RISC

#### 명령어 집합

- CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합, 명령어 집합 구조(ISA: Instruction Set Architecture)라고 한다. CPU마다 ISA가 다를 수 있다.
- ISA는 CPU언어라고 볼 수 있다.
- ISA가 다르면 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터 개수, 메모리 관리 방법 등이 달라진다.
- 명령어 병렬 처리가 용이한 ISA가 있고, 그렇지 못한 ISA도 있다.

#### CISC(Complex Instruction Set Computer)

- 다양한 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 사용한다.
- 메모리에 접근하는 주소 지정 방식도 다양하다.
- 명령어가 워낙 복잡하고 다양하다보니 명령어의 크기와 실행되기까지의 시간이 일정하지 않다.
- 명령어가 규격화되지 않아 파이프라인이 효율적으로 명령어를 처리할 수 없다.
- 다양한 명령어를 제공하지만 복잡한 명령어의 사용빈도는 낮다.

#### RISC(Reduced Instruction Set Computer)

- CISC에 비해 명령어 종류가 적다.
- 명령어가 짧고 규격화(고정 길이 명령어)되어 있다. 1클럭 내외로 실행되는 명령어를 지향한다.
- 메모리 직접 접근 명령어는 load, store로 2개만 있다. CISC보다 주소 지정 방식의 종류가 적다.
- 레지스터를 적극 활용한다. 범용 레지스터의 개수가 많다.
- 사용 가능한 명령어의 종류가 적어 더 많은 명령어를 사용한다.

#### CISE, RISC 비교

|                 CISC                 |                 RISC                 |
| :----------------------------------: | :----------------------------------: |
|        복합하고 다양한 명령어        |         단순하고 적은 명령어         |
|           가변 길이 명령어           |           고정 길이 명령어           |
|        다양한 주소 지정 방식         |         적은 주소 지정 방식          |
| 프로그램을 이루는 명령어의 수가 적다 | 프로그램을 이루는 명령어의 수가 많다 |
|     여러 클럭에 걸쳐 명령어 수행     |       1클럭 내외로 명령어 수행       |
|       파이프라이닝하기 어려움        |        파이프라이닝하기 쉬움         |
